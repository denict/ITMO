; Написать программу, которая будет считывать CR ВУ на готовность. 
; Перед этим в памяти написать регистры MR ВУ, чтобы узнать разрешение прерывания соответствующего ВУ
; и узнать номер прерывания
ORG 0x0 ; Инициализация векторов прерывания
V0: WORD $DEFAULT ; вектор прерывания #0
WORD 0x180 
V1: WORD $INT1 ; вектор прерывания #1
WORD 0x180 
V2: WORD $INT2 ; вектор прерывания #2
WORD 0x180 
V3: WORD $DEFAULT ; вектор прерывания #3
WORD 0x180 
V4: WORD $DEFAULT ; вектор прерывания #4
WORD 0x180 
V5: WORD $DEFAULT ; вектор прерывания #5
WORD 0x180 
V6: WORD $DEFAULT ; вектор прерывания #6
WORD 0x180 
V7: WORD $DEFAULT ; вектор прерывания #7
WORD 0x180 

ORG 0x11
X: WORD 0x5

MAX: WORD 0x0016 ; 21, Максимальное значение X, которое удовлетворяет ОДЗ
MIN: WORD 0xFFEB ; -20,  Минимальное значение X, которое удовлетворяет ОДЗ
DEFAULT: IRET ; Обработка прерывания по умолчанию, просто возврат прерывания
ORG 0x20
MR0: WORD 0x8 ; Регистры MR ВУ, которые мы не можем считывать в AC (потому что по логике КВУ, в регистр MR можно только записывать)
MR1: WORD 0x9
MR2: WORD 0xA ; 1010
MR3: WORD 0xB
MR4: WORD 0xC
MR5: WORD 0xD
MR6: WORD 0xE
MR7: WORD 0xF
MR8: WORD 0xF
MR9: WORD 0xF
NUMBER_VU: WORD ?
INIT: 
       ADD #0xB
       ST NUMBER_VU 
       CLA
       IN 0x1D ; CR из ВУ-9
       AND #0x40 
       LOOP NUMBER_VU ; на единицу меньше #0x9 и т.д.
       BNE WORK ; Z=0 не равно 0. 6 бит равен 1
       IN 0x19 ; CR из ВУ-8
       AND #0x40
       LOOP NUMBER_VU ; NUMBER_VU = #0x8
       BNE WORK ; Z=0 не равно 0
       IN 0x15 ; CR из ВУ-7
       AND #0x40
       LOOP NUMBER_VU
       BNE WORK ; Z=0 не равно 0
       IN 0x11 ; CR из ВУ-6
       AND #0x40
       LOOP NUMBER_VU
       BNE WORK ; Z=0 не равно 0
       IN 0x0D ; CR из ВУ-5
       AND #0x40
       LOOP NUMBER_VU
       BNE WORK ; Z=0 не равно 0
       IN 0x0A ; CR из ВУ-4
       AND #0x40
       LOOP NUMBER_VU
       BNE WORK ; Z=0 не равно 0
       IN 0x7; CR из ВУ-3
       AND #0x40; CR записывается в 6 бит AC
       LOOP NUMBER_VU
       BNE WORK; Z=0 не равно 0
       IN 0x5; CR из ВУ-2  NUMBER_VU = 0x02
       AND #0x40; CR записывается в 6 бит AC
       LOOP NUMBER_VU
       BNE WORK; Z=0 не равно 0
       IN 0x3; CR из ВУ-1
       AND #0x40; CR записывается в 6 бит AC
       LOOP NUMBER_VU
       BNE WORK; Z=0 не равно 0
       IN 0x1; CR из ВУ-0
       AND #0x40; CR записывается в 6 бит AC
       LOOP NUMBER_VU ; NUMBER_VU = #0x0 и IP --> IP+1
       NOP
       BNE WORK; Z=0 не равно 0
       RET;




; Основная программа
START: DI ; Запрет прерываний, для того, чтобы обеспечить полное выполнение программы (атомарность)
    LD X ; Загрузка переменной X
    DEC ; Декрементация в цикле
    CALL CHECK ; Проверка значения на ОДЗ
    ST X ; Сохранение значения X
    EI ; Разрешение прерывания
    CALL INIT ; Вызов процедуры START для проверки готовности ВУ
    JUMP START ; Возврат в цикл

TEMPORARY: WORD ?
; После получения готовности от одного из ВУ, смотрим у соответствующего ВУ регистр  MR, 
; в котором хранится разрешение ВУ на прерывание и номер вектора прерывания   
WORK: LD #0x20 ; первая ячейка, в которой хранится MR
      ADD $NUMBER_VU  ; сдвиг 0x20 + NUMBER_VU для получения соответствующего регистра MR ВУ, которое вызвало готовность
      ST TEMPORARY
      LD (TEMPORARY) ; косвенная адресация, загрузка соответствующего адреса MR
      AND #0x7 ; сохраняем 3 младших бита MR, которые указывают на номер вектора прерывания 1010 & 0111 = 0010 = 2 
      ASL ; умножение на 2, чтобы получить адрес вектора прерывания
      ST TEMPORARY ; сохраняем во временную переменную, чтобы обратиться через косвенную 
      ; адресацию перейти по адресу на подпрограмму
      ; обработку прерывани я 
      LD (TEMPORARY) ; косвенная адресация, загрузка адреса обработчика прерывания
      ST TEMPORARY ; сохранение адреса обработчика в TEMPORARY
      JUMP (TEMPORARY) ; Переход на обработку прерывания
      

; Обработка прерывания ВУ 1
INT1:  DI ; Запрет на прерывание во время обработки прерывания
       LD X ; Загрузка переменной X
       NOP ; Отладочная точка остановки (NOP/HLT) для отладки. Всегда можно NOP заменить на HLT
       ASL ; X --> 2X
       ASL ; 2X --> 4X
       ASL ; 4X --> 8X
       SUB X ; 8X --> 7X
       SUB X ; 7X --> 6X
       ADD #2 ; -6X --> -6X + 2
       NOP
       OUT 2 ; Вывод F(x) = -6X + 2 в ВУ 1
       EI ; Разрешение прерывания
       IRET ; Возврат из обработки прерывания

TMP: WORD ?
; Обработка прерывания ВУ 2
INT2: DI ; Запрет на прерывание во время обработки прерывания
      CLA 
      IN 4 ; Считывание DR ВУ 2
      NOP 
      LD TMP ; Записываем в TMP значение DR ВУ 2
      ASL ; TMP --> 2TMP
      ADD TMP ; 2TMP --> 3TMP
      SUB X ;
      CALL CHECK ; Проверка значения на ОДЗ
      ST X ;
      NOP 
      EI ; Разрешение прерывания
      IRET ; Возврат из обработки прерывания



; Проверка принадлежности X к ОДЗ      
CHECK: CMP MAX ; Если X < MAX, то 
       BMI CHECK_MIN ; проверка на нижнюю границу X > MIN
       JUMP LD_MAX ; X не входит в ОДЗ, поэтому X будет принимать максимальное значение
CHECK_MIN: CMP MIN ; Проверка X > MIN
           BPL RETURN ; Если X > MIN, то X принадлежит ОДЗ, возвращаемся в основную программу
           JUMP LD_MAX    
LD_MAX: LD MAX ; Загрузка максимального числа в AC, Если X не принадлежит к ОДЗ
RETURN: RET ; Метка возврата из проверки на ОДЗ