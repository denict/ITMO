@ Задание №1. Разработать программу для работы с элементами массива M, в которой:
@ 1. Массив имеет следующие характеристики:
@ - адрес начала массива в памяти БЭВМ - 0x6d3;
@ - число измерений исходного массива - 1;
@ - количество элементов исходного массива - 16;
@ - каждый элемент является знаковым числом с разрядностью 14 бит;
@ - нумерация элементов начинается с 4;
@ - элементы хранятся в массиве по границам слов, нет необходимости в плотной упаковке;
@ 2. Для элементов массива необходимо вычислить 32-х битное значение функции:
@ - формула функции F(Mi) = 8 * Mi + 5221;
@ - 32-битный результат необходимо поместить в другой массив по адресу 0x400
@ - Результатом является массив 32-х разрядных чисел равным количеству элементов исходного массива.
@ Примечание: все числа представлены в десятичной системе счисления, если явно не указано иное.

ORG 0x100
ARRAY: WORD 0x6d3
ARRAY_ANSWER: WORD 0x400
ARR_LENGTH: WORD 16
ARR_INDEX: WORD 4
MASK_SIGN: WORD 0x2000 ; 0010 0000 0000 0000 - 14 бит
MASK_POS: WORD 0x1FFF ; 0001 1111 1111 1111
MASK_NEG: WORD 0xC000 ; 1100 0000 0000 0000
TEMPORARY: WORD ?
VAL32_1: WORD ?
VAL32_2: WORD ?
AD_NUM: WORD 0x1465 ; 5221_10
TIMES: WORD 7 ; для умножения числа на 8. 7, потому что число изначально даёт коэффициент 1 -> 8-1=7
START:
    CLA
    ST TEMPORARY
    LD (ARRAY)
    AND MASK_SIGN
    BNE IF_NEG
IF_POS:
    LD (ARRAY)+
    AND MASK_POS
    ST VAL32_1
    ST TEMPORARY
    CLA 
    ST VAL32_2 ; для очистки старшего байта
    POS_SUM_LOOP:
        LD VAL32_1
        ADD TEMPORARY ; складываем младшее слово с самим собой
        ST VAL32_1 ; AC + AC --> 2AC (младшее слово)
        CLA
        ADC VAL32_2 ; если произошёл переход из 15 бита (старшего разряда младшего слова) в 16 (младшего разряда старшего слова)
        ST VAL32_2
        LOOP TIMES ; делаем 7 раз сложение числа с самим собой
        JUMP POS_SUM_LOOP
        LD VAL32_1 ; после умножение, делаем сложение с числом 5221_10
        ADD AD_NUM ; сложение 8*M и числа 5221_10
        ST VAL32_1
        CLA
        ADC VAL32_2 ; если произошёл переход из 15 бита (старшего разряда младшего слова) в 16 (младшего разряда старшего слова)
        ST VAL32_2
        LD #7 ; восстанавливаем множитель
        ST TIMES
        JUMP TO_ARRAY

IF_NEG:
    LD (ARRAY)+
    OR MASK_NEG
    ST VAL32_1
    ST TEMPORARY
    LD #0xFF
    ST $VAL32_2 ; 0xFFFF в старшем слове
    NEG_SUM_LOOP:
        LD VAL32_1
        ADD TEMPORARY
        ST VAL32_1
        CLA
        LD #0xFF ; для сложения старшего слова с самим собой
        ADC VAL32_2 ; если произошёл переход из 15 бита (старшего разряда младшего слова) в 16 (младшего разряда старшего слова)
        ST VAL32_2
        LOOP TIMES ; делаем 7 раз сложение числа с самим собой
        JUMP NEG_SUM_LOOP
        LD VAL32_1 ; после умножение, делаем сложение с числом 5221_10
        ADD AD_NUM ; сложение 8*M и числа 5221_10
        ST VAL32_1
        CLA
        ADC VAL32_2 ; если произошёл переход из 15 бита (старшего разряда младшего слова) в 16 (младшего разряда старшего слова)
        ST VAL32_2
        LD #7
        ST TIMES
        JUMP TO_ARRAY

TO_ARRAY:
    LD VAL32_1
    ST (ARRAY_ANSWER)+
    LD VAL32_2
    ST (ARRAY_ANSWER)+
    LOOP ARR_LENGTH ; уменьшаем количество оставшихся итераций на 1
    JUMP START
STOP: HLT

ORG 0x6d3
WORD 0x1000
WORD 0x9000
WORD 0x0001
WORD 0x0010
WORD 0x0100
WORD 0x0200
WORD 0x0400
WORD 0x1000
WORD 0x2000
WORD 0x4000
WORD 0xFFFF
WORD 0xD011
WORD 0xC001
WORD 0x2111
WORD 0x2222
WORD 0x3111